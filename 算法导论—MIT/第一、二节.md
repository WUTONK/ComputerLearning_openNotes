# **第一、二节**



### <u>算法的意义</u>

算法是为了更高的性能所诞生，且是程序的实现方式。性能会牺牲安全，可扩展和可维护性。

现代程序最重要的是安全而非速度



#### 算法问题

1.排序问题

排序内包含了很多基本的算法。

先输入一组数字，从a1,a2……an，按照需求重新排列后作为输出，这里是由大到小排列，每个数字仅出现一次，从小到大递增。

使用的算法为插入排序(sort)，用伪代码（pseudocode）表示。

 

设一个数组A，找到A的第j个位置，把这个位置的值提取出来，在这里称为key。有一个常量不变（已经排序过的位置）。原理是选取j的key，复制后逐步往一个方向推，直到找到一个合适的位置，然后插入。

2.归并排序 （后讲）

先输入一个数组A[1..n]，然后经过三个基本步骤；1.检查是否已经排序好（n=1）、2.递归；对A[1到n/2向上取整]，以及对A[n/2+1向上取整..n]这部分排序,所以输入是分成两半的。3.把排好序的两个表归并。

![截屏2022-03-25 上午9.56.08](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-25 上午9.56.08.png)

左边是A[1..n/2]，另一个是A[n/2+1..n]



要归并他们，要先找出最小元素，然后把最小的输出到最终数组，然后找下一个

对于总数为n的输入，时间是Θ(n)的，因为每个操作耗费常数时间；与输入规模成正比，这就是线性时间

##### 递归程序

为n个元素排序的时间是T(n)，第一步我们只检查数是否为1，是则返回，只耗费固定的机器指令，也就是常数时间，称为Θ(1)，回到递归，我们省略细节，写成2T(n/2)

![image-20220326122459053](/Users/wuzitong/Library/Application Support/typora-user-images/image-20220326122459053.png)

要么做第一步就返回就完事了，要么没返回，接着做二三步。

把这些都加起来，就是Θ(n)+Θ(1)，实际上就是Θ(n)，因为Θ(1)是低阶项，要略去。

现在公式里用T(n/2)来表示T(n)



##### 递归树方法

![截屏2022-03-26 下午12.57.05](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-26 下午12.57.05.png)

用cn (c是大于零的常数乘以n)把隐式的Θ(n)替换掉



构造递归树的方法如下：

先把递归式的左半部分写下来 **T(n)** 然后等于，接下来写成树状结构，我做了cn的工作，加上必须在子节点做这些**T(n/2)** + **T(n/2)**，![截屏2022-03-26 下午1.04.11](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-26 下午1.04.11.png)这样就得到了2T(n/2) + cn。![截屏2022-03-26 下午1.06.09](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-26 下午1.06.09.png)先等于，然后这里有个cn，子节点是cn/2，另一边也是，现在，每一项都是一个T(n/4)了，然后又是等于号。

如果一直做下去，就会变成这样

![截屏2022-03-26 下午1.08.11](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-26 下午1.08.11.png)

然后一直探下去，直到到达叶节点——只有T(1)，即Θ(1)。![截屏2022-03-26 下午1.09.10](/Users/wuzitong/Library/Application Support/typora-user-images/截屏2022-03-26 下午1.09.10.png)

这个树的高度是lg n，实际上是精确接近，因为是从N出发的，(n/2,n/4....)然后一直算到1，从n到1点折半次数是lgn,所以高度也是



#### 运行时间

算法的速度取决于几个因素：输入本身（与算法越逆向越慢），输入规模（越大越慢）

算法通常统计相对速度（同样性能设备上的对比）而不是绝对速度 



##### 最坏情况分析（用户友好）

$T(n)$

待处理规模可以看待为运行时间的参数

需要求出运行时间的上限，使其不会超过某个定量。有时则是平均值（时间期望值）：每种输入的运行时间，乘以某种输入出现的概率（加权平均），我们还需要一个输入的统计分布的假设。

一种常见的方式是所有规模 为n的输入情况都是平均分布的



##### 最好情况分析

不重要，主要是为了计算出可能的时间范围



### 算法的大局观

##### 渐进分析(asymptotic analysis)概念：

忽略掉依赖于机器的常量，不去检查实际的运行时间，而是**去关注运行时间的增长**。



#### 渐进符号

##### Θ（Theta 渐进紧确界记号） 

 在一个公式中，弃去低阶项（low-order），并忽略前面的常数因子 例：3n^3 + 90n^2 - 5n + 6046 看什么是要弃去的低阶项；n^3比n^2阶数高，所以要把这些都弃去，把前面的常数因子也忽略掉，所以这个公式是Θ (n^3)。

![image-20220325084531898](/Users/wuzitong/Library/Application Support/typora-user-images/image-20220325084531898.png)

当n趋于无穷大的时候，那么低阶的n总会在某个n比高阶的快，比如一个Θ(n^2)的算法在一定no后肯定比Θ(n^3）快，因为计算机速度只是影响常数因子，且计算量随输入规模是不断增长的。这就是Θ的伟大之处；满足相对和绝对速度计算的需要。

不过当n大到计算机难以运行时，低速算法反而更快



进行操作数目计数的一种方法；内存引用计数——实际访问了上个变量多少次

![image-20220325092339420](/Users/wuzitong/Library/Application Support/typora-user-images/image-20220325092339420.png)

当j=2,从j循环到n ，对j的每一个值取值(取n次)，在渐进上，这等于j乘以某个常数；Θ(j)次操作,这是个Θ(n^2)的算法（随着计算量时间不断递增），实际上是个算术级数（1+2+3……+n）



Θ的数学含义：
对一个给定的函数g(n)，用Θ(g(n))来表示以下函数的集合
Θ(g(n))={ f(n)：存在正常量c1、c2和n0，使得对所有n ≥ n 0 n_{0} n 
0 有0≤ c1g(n) ≤ f(n) ≤ c2g(n) }
Θ(g(n))要求每个成员 f(n)∈Θ(g(n)) 均渐进非负，即当n足够大时 f(n) 非负，渐进正函数就是对所有足够大的n均为正的函数。（下面写错了，是最低项）

![image-20220325084132745](/Users/wuzitong/Library/Application Support/typora-user-images/image-20220325084132745.png)



##### O (大O符号)



##### Ω (omega 渐进下界符号)



##### o (非渐进紧确上界)



##### ω (非渐进紧确下界)

 